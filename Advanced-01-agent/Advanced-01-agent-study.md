## 🎤 Section 1. 에이전트의 정의와 ReAct 루프 (04분)

### [1단계: 에이전트의 정의 - 말에서 행동으로] (02분)

**(슬라이드: 챗봇 vs 에이전트 비교 장표)**

"안녕하세요. 오늘 우리는 LLM이 단순히 '말을 잘하는 인공지능'을 넘어, 스스로 판단하고 행동하는 **'에이전트'**로 진화하는 과정을 살펴볼 것입니다."

"우리가 흔히 쓰는 일반적인 챗봇은 사용자의 질문에 대해 학습된 데이터를 바탕으로 텍스트를 생성하는 데 그칩니다. 하지만 **에이전트(Agent)**는 다릅니다. 에이전트는 특정 목표(Goal)가 주어지면, 그 목표를 달성하기 위해 자신이 가진 '도구(Tool)' 중 무엇을 사용할지 스스로 결정하고 실행하는 **대리인**입니다."

"예를 들어, '오늘 삼성전자 주가 알려줘'라는 요청에 대해 챗봇은 '제가 실시간 정보를 알 수 없습니다'라고 답하겠지만, 에이전트는 '주가 검색 도구'를 선택해 직접 데이터를 가져오는 **행동**을 합니다. 즉, 에이전트의 핵심은 **텍스트 생성에서 행동(Action)으로의 확장**에 있습니다."

### [2단계: ReAct 사고 루프 - 에이전트의 뇌 구조] (02분)

**(슬라이드: Thought → Action → Observation 순환 도식)**

"그렇다면 에이전트는 어떤 방식으로 생각하고 움직일까요? 현대 에이전트의 가장 표준적인 사고 방식인 **ReAct(Reasoning + Acting)** 루프를 이해해야 합니다."

"ReAct는 크게 세 단계의 무한 루프로 구성됩니다."

1. **Thought (추론):** 모델이 현재 상황을 분석하고, 목표 달성을 위해 '다음에 무엇을 해야 할지' 스스로 계획을 세우는 단계입니다.
2. **Action (행동):** 세워진 계획에 따라 외부 도구(Function)를 실제로 호출하는 단계입니다.
3. **Observation (관찰):** 실행된 결과값을 확인하는 단계입니다. 모델은 이 결과가 내 목표에 부합하는지, 추가 작업이 필요한지 관찰합니다.

"모델은 이 **추론-행동-관찰**의 루프를 목표가 달성될 때까지 반복합니다. 이 과정이 반복되면서 에이전트는 단순한 답변기가 아니라, 문제를 해결해 나가는 **지능적인 주체**로 거듭나게 됩니다."

---

## 🎤 Section 2. Function Calling 원리와 제어권의 이전 (06분)

### [1단계: 제어권의 패러다임 시프트 - What, not How] (02분)

**(슬라이드: 전통적 프로그래밍 vs 에이전틱 워크플로우 비교)**

"우리가 지금까지 해온 프로그래밍은 'How'의 세계였습니다. 개발자가 `if-else` 문을 촘촘하게 짜서, 'A 상황에는 B 함수를 실행해'라고 모든 경로를 미리 정해두었죠. 이것을 **결정론적 경로**라고 합니다."

"하지만 에이전트의 세계에서는 이 제어권이 개발자로부터 모델의 **Reasoning(추론)**으로 넘어갑니다. 개발자는 모델에게 '어떤 도구가 있는지'와 '최종 목적이 무엇인지'인 **What**만 알려줍니다. 그러면 모델이 실시간으로 상황을 판단해서 실행 경로를 스스로 결정합니다."

"이것이 바로 **'제어권의 이전'**입니다. 이제 소프트웨어는 정해진 레일을 달리는 기차가 아니라, 목적지를 보고 스스로 길을 찾아가는 자율주행 자동차가 되는 것입니다."

---

### [2단계: 통계적 구조화 - Constrained Decoding] (02분)

**(슬라이드: 토큰 확률 분포 그래프와 JSON 규격 시각화)**

"그럼 기술적으로 어떻게 모델이 우리가 원하는 코드(JSON)를 정확히 뱉어낼까요? 모델은 본래 수다쟁이입니다. 그냥 두면 '네, 제가 함수를 실행해 드릴게요!'라며 불필요한 말을 하죠. 여기서 **Constrained Decoding(제약된 디코딩)**이라는 마법이 일어납니다."

"쉽게 설명하면, 다음 단어를 선택할 때 모델이 멋대로 떠들지 못하도록 확률 값을 강제로 조정하는 것입니다. '다음 단어는 반드시 `{` 여야 해', '그다음엔 반드시 `name`이 와야 해'라고 **토큰의 확률 분포를 규격화된 JSON Schema에 가두는 것**입니다. 이를 통해 통계적 추론 모델이 공학적으로 사용 가능한 '구조화된 데이터'를 출력하게 됩니다."

---

### [3단계: Semantic Matching - 의미로 찾는 도구] (02분)

**(슬라이드: 함수 명세서(Description)가 모델의 눈에 보이는 방식)**

"마지막으로 모델이 수많은 함수 중 '왜 이 함수를 선택했는가'에 대한 원리입니다. 바로 **Semantic Matching**입니다. 모델은 우리가 작성한 함수의 이름과 `Description(설명)`을 텍스트로 읽습니다."

"사용자의 질문과 가장 의미론적으로 가까운(Semantic) 도구를 수학적으로 계산해서 찾아내는 것이죠. 그래서 Function Calling에서 가장 중요한 코딩은 파이썬 코드가 아니라, **'함수가 무엇을 하는지 모델이 이해하기 쉽게 설명하는 글'**이 됩니다. 이 원리를 이해해야 뒤에서 다룰 에이전트적 프롬프트 설계를 제대로 할 수 있습니다."

---

## 🎤 Section 3. 에이전트적 사고와 프롬프트 실습 (07분)

### [1단계: 에이전트 설계의 5대 기둥] (02분)

**(슬라이드: Persona, Context, Task, Constraint, Output 5각형 도식)**

"앞서 우리는 모델에게 제어권이 넘어갔다는 것을 배웠습니다. 그렇다면 이제 개발자의 역할은 무엇일까요? 바로 에이전트가 올바른 판단을 내릴 수 있도록 **'사고의 가드레일'**을 설계하는 것입니다. 이를 위해 우리는 5가지 구조적 요소를 프롬프트에 담아야 합니다."

"누구인지 정의하는 **Role(Persona)**, 어떤 상황/데이터인지 알려주는 **Context**, 무엇을 해야 하는지 명시하는 **Task**, 어떻게 사고할지 단계별로 명시하는 **Chain of Thought**, 그리고 마지막으로 어떤 형태로 결과를 내놓을지 정하는 **Output Format**입니다. 이 5가지가 갖춰졌을 때 비로소 모델은 단순한 챗봇이 아닌 '책임감 있고 정밀한 에이전트'처럼 행동합니다."

### [2단계: 미니 실습 - 회의 시간 잡기] (04분)

**(슬라이드: Case A와 Case B의 프롬프트 및 결과 비교)**

"백문이 불여일견이죠. 실무에서 자주 마주치는 문제로 실습을 해보겠습니다. 주제는 **'5명의 팀원이 모두 참석 가능한 1시간 회의 시간을 잡기'**입니다."

"먼저 **Case A**입니다. 단순히 '모든 팀원이 참석 가능한 1시간 회의 시간을 정해줘'라고 물어보고, 각 팀원의 가용 시간을 나열하겠습니다. 아마 모델은 이렇게 대답할 겁니다. '대략 오후 3시~4시 정도가 좋을 것 같습니다' 또는 '각 팀원의 시간을 보면 3시~4시 30분 사이가 가능해 보입니다' 같은 대충 추정한 답변이죠. 1분 단위로 정밀하게 계산하지 않고, 각 팀원의 가용 시간을 정확히 대조하지 않습니다."

"이제 **Case B**, 구조적 설계를 적용해 보겠습니다.

- **Role:** 너는 1분의 오차도 허용하지 않는 글로벌 대기업의 '수석 스케줄러 에이전트'야.
- **Context:** 5명 팀원의 월요일 가용 시간 데이터를 제공하고, 60분 연속 회의 시간을 잡아야 해.
- **Task:** 모든 팀원이 60분 내내 참석 가능한 시간을 찾되, 불가능하면 참석 인원이 가장 많은 시간대를 제시해.
- **Chain of Thought:** 데이터 정렬 → 타임라인 분석 → 개별 검증 → 인원수 비교 → 최종 선발 및 자기 수정의 5단계 사고 과정을 거쳐야 해.
- **Output Format:** 최종 제안 시간, 참석 확정 인원, 불참 인원 및 사유, 검증 로그를 구조화된 형식으로 제시해야 해.

이렇게 명령하면 모델은 비로소 에이전트로서 **정밀한 계산**을 시작합니다. '각 팀원의 가용 시간을 1분 단위로 대조한 결과, 15:00~16:00 시간대에 A, B, E만 참석 가능하고, C는 16:00부터만 가능하므로...' 이처럼 논리적 검증 과정을 거쳐 명확한 답변을 내놓게 되죠."

### [3단계: Hallucination과 Self-Correction] (01분)

**(슬라이드: 에러 메시지를 읽고 스스로 사과하며 수정하는 모델의 로그 화면)**

"하지만 에이전트도 실수를 합니다. 존재하지 않는 함수를 부르거나, 숫자가 들어가야 할 곳에 문자를 넣는 '할루시네이션'이 발생하죠. 이때 중요한 것이 앞서 배운 **ReAct 루프의 Observation(관찰)**입니다."

"에이전트는 실행 에러 메시지를 보고 '아, 내가 인자를 잘못 넣었구나'라고 스스로 판단(Thought)합니다. 그리고 다시 올바른 값을 넣어 재시도(Self-Correction)하죠. 이처럼 에이전트적 사고는 한 번에 성공하는 것이 아니라, 오류를 스스로 교정하며 목표를 향해 나아가는 과정임을 이해해야 합니다."

---

## 🎤 Section 4. Raw Function Calling 구현과 MCP로의 연결 (08분)

### [1단계: Schema Design - 모델이 읽는 매뉴얼] (02분)

**(슬라이드: 함수 코드와 JSON Schema 명세가 나란히 놓인 장표)**

"이제 에이전트의 '뇌'인 프롬프트를 넘어, 실제 '손과 발'인 코드를 연결해 보겠습니다. 그 핵심 매뉴얼이 바로 **JSON Schema**입니다. 우리는 모델에게 파이썬 코드 전체를 주지 않습니다. 대신 함수의 이름, 이 함수가 무엇을 하는지에 대한 설명, 그리고 어떤 파라미터가 필요한지를 정의한 '명세서'만 전달합니다."

"여기서 가장 중요한 것은 `description` 필드입니다. 앞서 배운 Semantic Matching의 원리에 따라, 모델은 이 설명을 읽고 '아, 지금 주가를 확인해야 하니 이 함수를 불러야겠구나'라고 판단합니다. 즉, 개발자는 모델이 읽을 수 있는 **구조화된 인터페이스**를 설계하는 것입니다."

---

### [2단계: The Loop - 에이전트를 움직이는 심장] (04분)

**(슬라이드: While 루프와 tool_calls 파싱 로직이 담긴 코드 스니펫)**

"그럼 이 명세서를 받은 모델은 어떻게 행동할까요? 여기서 우리는 **While 루프**를 구현해야 합니다. 에이전트의 심장 박동과도 같은 루프죠."

1. **모델의 응답 확인:** 모델이 일반 텍스트가 아닌 `tool_calls`라는 특별한 신호를 보냈는지 확인합니다.
2. **함수 실행:** 우리가 짠 파이썬 코드가 모델이 요청한 인자값을 가지고 실제 API나 DB를 호출합니다.
3. **결과 피드백:** 함수의 실행 결과(Observation)를 다시 모델에게 던져줍니다.

"이 루프는 모델이 '이제 답을 찾았으니 끝내겠다'라는 신호(Final Answer)를 보낼 때까지 반복됩니다. 우리가 라이브러리 없이 이 루프를 직접 구현해 보면, 에이전트가 단순히 코드를 실행하는 것이 아니라 **'결과를 보고 다음 행동을 계속해서 결정하는 존재'**라는 점을 뼈저리게 체감할 수 있습니다."

---

### [3단계: MCP로의 연결 - 표준화의 필요성] (02분)

**(슬라이드: 다양한 모델과 도구가 복잡하게 얽힌 모습 vs MCP로 정리된 모습)**

"자, 그런데 문제가 하나 있습니다. 오늘 우리는 이 함수 명세를 직접 딕셔너리로 짰습니다. 하지만 만약 모델이 바뀐다면? 혹은 연동해야 할 도구가 100개라면 어떨까요? 매번 이 복잡한 Schema를 새로 짜고 루프를 관리하는 건 너무나 고통스러운 일일 겁니다."

"에이전트와 도구 사이의 대화 방식이 제각각인 이 혼란을 해결하기 위해 등장한 것이 바로 **MCP(Model Context Protocol)**입니다. 에이전트가 어떤 도구와도 '플러그 앤 플레이' 방식으로 연결될 수 있도록 하는 일종의 **표준 규격**이죠."

"우리는 방금 에이전트의 기초 체력을 다졌습니다. 이제 이 에이전트들을 어떻게 더 쉽고 표준화된 방식으로 확장할 수 있는지, 다음 세션인 MCP 담당자분을 모시고 이야기를 들어보겠습니다."
