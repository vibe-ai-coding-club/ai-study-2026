# 📝 Section 3 미니 실습 프롬프트

이 파일의 프롬프트를 복사해서 ChatGPT나 Gemini 웹사이트에 붙여넣어 사용하세요.

---

## 📋 Case A: 일반적인 챗봇 프롬프트

**아래 프롬프트를 복사하세요:**

```
모든 팀원이 참석 가능한 1시간 회의 시간을 정해줘.
A: 월요일 오후 2시~4시 가능
B: 월요일 오후 3시~5시 가능
C: 화요일 전일 가능하지만 월요일은 4시 이후만 가능
D: 월요일 오후 1시~3시 30분 가능
E: 모든 요일 오후 3시~4시 30분 가능
```

### 예상 결과

- 대충 시간을 추정하거나 근사치로 답변
- 정확한 시간 계산 없이 "대략 3시~4시" 같은 모호한 답변
- 각 팀원의 가용 시간을 정밀하게 대조하지 않음
- 논리적 검증 없이 답변

---

## ✅ Case B: 구조화된 스크립트를 적용한 에이전트 프롬프트

**아래 프롬프트를 복사하세요:**

```
# Role
너는 1분의 오차도 허용하지 않는 글로벌 대기업의 '수석 스케줄러 에이전트'야. 숫자를 대충 훑지 않고, 각 팀원의 가용 시간을 정밀하게 대조하여 논리적 모순을 찾아내는 데 특화되어 있어.

# Context (데이터 주입)
다음은 5명 팀원의 월요일 가용 시간 데이터야. 이 데이터를 바탕으로 60분(연속된 1시간) 회의 시간을 잡아야 해.
- A: 월요일 오후 2시 ~ 4시 가능
- B: 월요일 오후 3시 ~ 5시 가능
- C: 화요일은 전일 가능하지만, 월요일은 오후 4시 이후부터만 가능
- D: 월요일 오후 1시 ~ 3시 30분 가능
- E: 모든 요일 오후 3시 ~ 4시 30분 가능

# Task
모든 팀원이 "60분 내내" 한 명도 빠짐없이 참석 가능한 최적의 시간을 찾아줘. 만약 전원 참석이 불가능하다면, "60분 전체를 온전히 채울 수 있는 인원"이 가장 많은 시간대를 최종안으로 제시해.

# Chain of Thought (에이전트 사고 로직)
Step 1. [데이터 정렬]: 각 팀원별 월요일 가용 시간을 [시작-종료] 시각으로 명확히 리스트업한다.
Step 2. [타임라인 분석]: 14:00, 15:00, 16:00 등 정각을 기준으로 60분 단위의 모든 후보 시간대(예: 14:00~15:00, 14:30~15:30, 15:00~16:00 등)를 검토한다.
Step 3. [개별 검증]: 각 후보 시간대별로 5명의 팀원이 '60분 전체' 가용 가능한지 한 명씩 OX로 체크한다. (단 1분이라도 겹치지 않으면 '불참'으로 간주한다.)
Step 4. [인원수 비교]: 각 후보 시간대별 '참석 확정 인원수'를 계산한다.
Step 5. [최종 선발 및 자기 수정]:
  - 후보지 중 참석 인원수가 가장 많은 시간대를 최종안으로 고른다.
  - 만약 인원수가 같다면 가장 이른 시간대를 고른다.
  - 답변을 출력하기 전, 선택한 시간대에 불참자로 분류된 사람이 정말로 불참 사유가 맞는지 데이터를 다시 대조하여 검증한다.

# Output Format
1. 최종 제안 시간: [00:00 ~ 00:00]
2. 참석 확정 인원 (0명): [이름 나열]
3. 불참 인원 및 사유: [이름] - [사유: 가용 시간과 제안 시간 대조 결과]
4. 검증 로그: 5명 각각에 대해 제안 시간 60분 내내 참석 가능 여부(Yes/No) 표시
```

### 예상 결과

- 정확한 시간 계산
- 각 팀원의 가용 시간을 정밀하게 대조
- 논리적 검증 과정을 거친 명확한 답변
- 구조화된 형식으로 결과 제시

---

## 🎯 실습 방법

1. **ChatGPT** (https://chat.openai.com) 또는 **Gemini** (https://gemini.google.com) 웹사이트 접속
2. **Case A** 프롬프트를 복사해서 붙여넣고 실행
3. 결과 확인 (대충 추정한 답변 확인)
4. **Case B** 프롬프트를 복사해서 붙여넣고 실행
5. 결과 비교 (정밀한 계산과 검증 과정 확인)

---

## 📚 에이전트 설계의 5대 기둥

Case B 프롬프트에 포함된 5대 기둥:

| 기둥                 | 설명                              | Case B 예시                              |
| -------------------- | --------------------------------- | ---------------------------------------- |
| **Role (Persona)**   | 누구인지 정의                     | "수석 스케줄러 에이전트"                 |
| **Context**          | 어떤 상황/데이터인지              | "5명 팀원의 월요일 가용 시간 데이터"     |
| **Task**             | 무엇을 해야 하는지                | "60분 내내 전원 참석 가능한 시간 찾기"   |
| **Chain of Thought** | 어떻게 생각할지 (Constraint 포함) | "Step 1~5의 사고 로직"                   |
| **Output Format**    | 어떤 형태로 결과를 낼지           | "1. 최종 제안 시간 2. 참석 확정 인원..." |

---

## 💡 학습 포인트

### Case A의 문제점

- ❌ 구조적 설계 없음
- ❌ 대충 추정하는 답변
- ❌ 정밀한 시간 계산 없음
- ❌ 논리적 검증 과정 없음

### Case B의 효과

- ✅ 5대 기둥 모두 포함 (Role, Context, Task, Chain of Thought, Output Format)
- ✅ 정밀한 시간 계산 (1분 단위 검증)
- ✅ 논리적 사고 과정 명시 (Chain of Thought)
- ✅ 구조화된 결과 제시
- ✅ 자기 검증 과정 포함

### 핵심 교훈

에이전트가 올바른 판단을 내리려면, 개발자가 **'사고의 가드레일'**을 설계해야 합니다.

- **Role**: 에이전트의 정체성과 전문성 부여
- **Chain of Thought**: 모델이 어떻게 사고할지 단계별로 명시
- **Output Format**: 일관되고 검증 가능한 결과 형식 지정

5대 기둥을 통해 모델은 단순한 챗봇이 아닌 '책임감 있고 정밀한 에이전트'로 거듭납니다.
